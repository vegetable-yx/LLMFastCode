Rewrite `slow_performance` into `max_performance`, keeping inputs, outputs, and behavior identical with allowable total squared precision error of 1e-3.  
Only apply performance optimizations (algebraic simplification, cache-friendly memory access, SIMD/AVX-2, loop unrolling, etc.).  

**Assume the code executes on a single core, DO NOT introduce multithreading or parallelism.**

**Target system**
- Intel(R) Core(TM) Ultra 7 265K CPU @ 3.90GHz
- Caches: 240 KB L1 D + 32 KB L1 I per core, 3.00 MB L2 per core, 30 MB shared L3  
- GCC 12 on Debian Bookworm; compile with `-O3 -march=native -mavx2 -std=c++11`

**Hints**
- Write SIMDe code with <immintrin.h> whenever possible.
- Do not use libc functions as their performance is not good.

Return **only** the full, ready-to-compile `max_performance` functionâ€”no other text, comments, or explanations.


```
#include <immintrin.h>
#include "common.h"

void slow_performance(double *__restrict x, double *__restrict h, double *__restrict y)
{
    const int ON = N - K + 1;
    for (int i = 0; i < ON; i++)
    {
        for (int j = 0; j < ON; j++)
        {
            GET_Y(i, j) = 0.0;
            for (int k0 = 0; k0 < K; k0++)
            {
                for (int k1 = 0; k1 < K; k1++)
                {
                    GET_Y(i, j) += (i + j + k0 + k1 - 1) * GET_H(k0, k1) * fabs(GET_X(i + k0, j + k1));
                }
            }
        }
    }
}

void max_performance(double *__restrict x, double *__restrict h, double *__restrict y)
{
}
```


================================
#include <immintrin.h>
#include "common.h"
#include <cmath>

void max_performance(double *__restrict x, double *__restrict h, double *__restrict y)
{
    const int ON = N - K + 1;
    for (int i = 0; i < ON; i++)
    {
        for (int j = 0; j < ON; j++)
        {
            double sum = 0.0;
            for (int k0 = 0; k0 < K; k0++)
            {
                __m256d h_vec = _mm256_set1_pd(GET_H(k0, 0));
                __m256d sum_vec = _mm256_setzero_pd();
                for (int k1 = 0; k1 < K / 4 * 4; k1 += 4)
                {
                    __m256d x_vec = _mm256_loadu_pd(x + (i + k0) * N + j + k1);
                    __m256d abs_x_vec = _mm256_abs_pd(x_vec);
                    __m256d k_sum_vec = _mm256_set_pd(i + j + k0 + k1 + 3, i + j + k0 + k1 + 2, i + j + k0 + k1 + 1, i + j + k0 + k1);
                    __m256d h_temp_vec = _mm256_loadu_pd(h + k0 * K + k1);
                    h_temp_vec = _mm256_mul_pd(h_temp_vec, k_sum_vec);
                    sum_vec = _mm256_fmadd_pd(h_temp_vec, abs_x_vec, sum_vec);
                }
                  double partial_sum = sum_vec[0] + sum_vec[1] + sum_vec[2] + sum_vec[3];
                  sum += partial_sum;

                for (int k1 = K / 4 * 4; k1 < K; k1++)
                {
                     sum += (i + j + k0 + k1 - 1) * GET_H(k0, k1) * fabs(GET_X(i + k0, j + k1));
                }
            }
            GET_Y(i, j) = sum;
        }
    }
}
>>>
make: *** [Makefile:13: benchmark] Error 1
<<<
CE
================================
#include <immintrin.h>
#include "common.h"

void max_performance(double *__restrict x, double *__restrict h, double *__restrict y)
{
    const int ON = N - K + 1;
    for (int i = 0; i < ON; i++)
    {
        for (int j = 0; j < ON; j++)
        {
            double sum = 0.0;
            for (int k0 = 0; k0 < K; k0++)
            {
                for (int k1 = 0; k1 < K; k1++)
                {
                    sum += (double)(i + j + k0 + k1 - 1) * GET_H(k0, k1) * fabs(GET_X(i + k0, j + k1));
                }
            }
            GET_Y(i, j) = sum;
        }
    }
}
>>>
Starting program. 2 functions registered.

Running: slow_performance
73502.3 cycles

Running: max_performance
72630.1 cycles
<<<
73502.3 / 72630.1 = 1.0120088
================================
#include <immintrin.h>
#include "common.h"
#include <cmath>

void max_performance(double *__restrict x, double *__restrict h, double *__restrict y)
{
    const int ON = N - K + 1;
    for (int i = 0; i < ON; i++)
    {
        for (int j = 0; j < ON; j++)
        {
            double sum = 0.0;
            for (int k0 = 0; k0 < K; k0++)
            {
                const double hk0 = GET_H(k0, 0);
                const double hk1 = GET_H(k0, 1);

                double abs_x_ik0_j = std::fabs(GET_X(i + k0, j));
                sum += (i + j + k0 - 1) * hk0 * abs_x_ik0_j;
                double abs_x_ik0_j_plus_1 = std::fabs(GET_X(i + k0, j + 1));
                sum += (i + j + k0) * hk1 * abs_x_ik0_j_plus_1;
                
                if(K > 2){
                    const double hk2 = GET_H(k0, 2);
                    double abs_x_ik0_j_plus_2 = std::fabs(GET_X(i + k0, j + 2));
                    sum += (i + j + k0+1) * hk2 * abs_x_ik0_j_plus_2;
                }
            }
            GET_Y(i, j) = sum;
        }
    }
}
>>>
The result of the 2th function is not correct.

Running: slow_performance
71623.3 cycles

Running: max_performance
51813.4 cycles
<<<
WA
================================