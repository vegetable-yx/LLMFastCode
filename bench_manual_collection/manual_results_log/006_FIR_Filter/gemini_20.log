Rewrite `slow_performance` into `max_performance`, keeping inputs, outputs, and behavior identical with allowable total squared precision error of 1e-3.  
Only apply performance optimizations (algebraic simplification, cache-friendly memory access, SIMD/AVX-2, loop unrolling, etc.).  

**Assume the code executes on a single core, DO NOT introduce multithreading or parallelism.**

**Target system**
- Intel(R) Core(TM) Ultra 7 265K CPU @ 3.90GHz
- Caches: 240 KB L1 D + 32 KB L1 I per core, 3.00 MB L2 per core, 30 MB shared L3  
- GCC 12 on Debian Bookworm; compile with `-O3 -march=native -mavx2 -std=c++11`

**Hints**
- Write SIMDe code with <immintrin.h> whenever possible.
- Do not use libc functions as their performance is not good.

Return **only** the full, ready-to-compile `max_performance` functionâ€”no other text, comments, or explanations.


```
#include <immintrin.h>
#include "common.h"

// Precondition: n = 1024, m = 4
void slow_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    for (int i = 0; i < n; ++i)
    {
        double sum = 0.0;
        for (int k = 0; k < m; ++k)
        {
            int x_index = i + (m - 1) - k;
            sum += (i + k + 1) * h[k] * std::abs(x[x_index]);
        }
        y[i] = sum;
    }
}

void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
}
```


================================
#include <immintrin.h>
#include "common.h"

// Precondition: n = 1024, m = 4
void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    __assume(n == 1024);
    __assume(m == 4);

    double h_values[4] = {h[0], h[1], h[2], h[3]};

    for (int i = 0; i < n; ++i)
    {
        double sum = 0.0;

        // Unroll the inner loop and vectorize with AVX2
        double x_val0 = x[i + 3];
        double x_val1 = x[i + 2];
        double x_val2 = x[i + 1];
        double x_val3 = x[i];

        sum += (i + 1) * h_values[3] * std::abs(x_val3);
        sum += (i + 2) * h_values[2] * std::abs(x_val2);
        sum += (i + 3) * h_values[1] * std::abs(x_val1);
        sum += (i + 4) * h_values[0] * std::abs(x_val0);
        y[i] = sum;
    }
}
>>>
make: *** [Makefile:13: benchmark] Error 1
<<<
CE
================================
#include <immintrin.h>
#include "common.h"
#include <cmath>

// Precondition: n = 1024, m = 4
void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    __m256d h_vec = _mm256_set_pd(h[3], h[2], h[1], h[0]);

    for (int i = 0; i < n; ++i)
    {
        double sum = 0.0;
        __m256d sum_vec = _mm256_setzero_pd();
        int x_index_start = i + (m - 1);
        for (int k = 0; k < m; k += 4)
        {
            int x_index3 = x_index_start - k;
            int x_index2 = x_index3 -1;
            int x_index1 = x_index2 - 1;
            int x_index0 = x_index1 - 1;

            double x_val0, x_val1, x_val2, x_val3;
            if (k == 0)
            {
                x_val0 = std::abs(x[x_index0]);
                x_val1 = std::abs(x[x_index1]);
                x_val2 = std::abs(x[x_index2]);
                x_val3 = std::abs(x[x_index3]);
            }
            else if (k == 4 -1){
                x_val0 = std::abs(x[x_index0]);
                x_val1 = 0.0;
                x_val2 = 0.0;
                x_val3 = 0.0;
            }
            else{
                x_val0 = std::abs(x[x_index0]);
                x_val1 = std::abs(x[x_index1]);
                x_val2 = std::abs(x[x_index2]);
                x_val3 = std::abs(x[x_index3]);

            }



            __m256d x_vec = _mm256_set_pd(x_val3, x_val2, x_val1, x_val0);


            __m256d factor_vec = _mm256_set_pd(i + k + 1, i + k, i + k - 1, i + k - 2);

            _mm256_storeu_pd(y + i, factor_vec);

            __m256d prod_vec = _mm256_mul_pd(factor_vec, x_vec);
            prod_vec = _mm256_mul_pd(prod_vec, h_vec);

            __m256d temp_sum = _mm256_hadd_pd(prod_vec, prod_vec);
            temp_sum = _mm256_hadd_pd(temp_sum, temp_sum);

            double scalar_sum = _mm256_cvtsd_f64(temp_sum);

           sum += scalar_sum;

        }
        y[i] = sum;
    }
}
>>>
Starting program. 2 functions registered.
The result of the 2th function is not correct.

Running: slow_performance
6133.51 cycles

Running: max_performance
6282.17 cycles
<<<
WA
================================
#include <immintrin.h>
#include "common.h"
#include <cmath>

void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    for (int i = 0; i < n; ++i)
    {
        double sum = 0.0;
        int x_index = i + m - 1;
        sum += (double)(i + 0 + 1) * h[0] * std::abs(x[x_index]);
        sum += (double)(i + 1 + 1) * h[1] * std::abs(x[x_index - 1]);
        sum += (double)(i + 2 + 1) * h[2] * std::abs(x[x_index - 2]);
        sum += (double)(i + 3 + 1) * h[3] * std::abs(x[x_index - 3]);
        y[i] = sum;
    }
}
>>>
Starting program. 2 functions registered.

Running: slow_performance
6191.47 cycles

Running: max_performance
1243.66 cycles
<<<
6191.47 / 1243.66 = 4.97842658
================================