Rewrite `slow_performance` into `max_performance`, keeping inputs, outputs, and behavior identical with allowable total squared precision error of 1e-3.  
Only apply performance optimizations (algebraic simplification, cache-friendly memory access, SIMD/AVX-2, loop unrolling, etc.).  

**Assume the code executes on a single core, DO NOT introduce multithreading or parallelism.**

**Target system**
- Intel(R) Core(TM) Ultra 7 265K CPU @ 3.90GHz
- Caches: 240 KB L1 D + 32 KB L1 I per core, 3.00 MB L2 per core, 30 MB shared L3  
- GCC 12 on Debian Bookworm; compile with `-O3 -march=native -mavx2 -std=c++11`

**Hints**
- Write SIMDe code with <immintrin.h> whenever possible.
- Do not use libc functions as their performance is not good.

Return **only** the full, ready-to-compile `max_performance` functionâ€”no other text, comments, or explanations.


```
#include <immintrin.h>
#include "common.h"

// Precondition: n = 1024, m = 4
void slow_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    for (int i = 0; i < n; ++i)
    {
        double sum = 0.0;
        for (int k = 0; k < m; ++k)
        {
            int x_index = i + (m - 1) - k;
            sum += (i + k + 1) * h[k] * std::abs(x[x_index]);
        }
        y[i] = sum;
    }
}

void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
}
```


================================
#include <immintrin.h>
#include <cmath>
#include <stdint.h>

void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    const __m256d h0 = _mm256_set1_pd(h[0]);
    const __m256d h1 = _mm256_set1_pd(h[1]);
    const __m256d h2 = _mm256_set1_pd(h[2]);
    const __m256d h3 = _mm256_set1_pd(h[3]);

    const __m256d one = _mm256_set1_pd(1.0);
    const __m256d two = _mm256_set1_pd(2.0);
    const __m256d three = _mm256_set1_pd(3.0);
    const __m256d four = _mm256_set1_pd(4.0);

    for (int i = 0; i < n; i += 4)
    {
        __m256d xi0 = _mm256_loadu_pd(&x[i + 3]);  // x[i+3], x[i+4], x[i+5], x[i+6]
        __m256d xi1 = _mm256_loadu_pd(&x[i + 2]);  // x[i+2], x[i+3], x[i+4], x[i+5]
        __m256d xi2 = _mm256_loadu_pd(&x[i + 1]);  // x[i+1], x[i+2], x[i+3], x[i+4]
        __m256d xi3 = _mm256_loadu_pd(&x[i + 0]);  // x[i+0], x[i+1], x[i+2], x[i+3]

        __m256d ax0 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi0);
        __m256d ax1 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi1);
        __m256d ax2 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi2);
        __m256d ax3 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi3);

        __m256d idx = _mm256_set_pd(i + 3, i + 2, i + 1, i + 0);
        __m256d t0 = _mm256_mul_pd(_mm256_add_pd(idx, one), _mm256_mul_pd(h0, ax0));
        __m256d t1 = _mm256_mul_pd(_mm256_add_pd(idx, two), _mm256_mul_pd(h1, ax1));
        __m256d t2 = _mm256_mul_pd(_mm256_add_pd(idx, three), _mm256_mul_pd(h2, ax2));
        __m256d t3 = _mm256_mul_pd(_mm256_add_pd(idx, four), _mm256_mul_pd(h3, ax3));

        __m256d result = _mm256_add_pd(_mm256_add_pd(t0, t1), _mm256_add_pd(t2, t3));
        _mm256_storeu_pd(&y[i], result);
    }
}

>>>
Starting program. 2 functions registered.

Running: slow_performance
6045.58 cycles

Running: maxperformance
1402.96 cycles
<<<
4.309160631807036
================================
```cpp
#include <immintrin.h>
#include <cmath>
#include "common.h"

void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    const int m1 = m - 1;

    __m256d h0 = _mm256_set1_pd(h[0]);
    __m256d h1 = _mm256_set1_pd(h[1]);
    __m256d h2 = _mm256_set1_pd(h[2]);
    __m256d h3 = _mm256_set1_pd(h[3]);

    for (int i = 0; i < n; i += 4)
    {
        __m256d xi0 = _mm256_loadu_pd(&x[i + m1 - 0]);
        __m256d xi1 = _mm256_loadu_pd(&x[i + m1 - 1]);
        __m256d xi2 = _mm256_loadu_pd(&x[i + m1 - 2]);
        __m256d xi3 = _mm256_loadu_pd(&x[i + m1 - 3]);

        __m256d ax0 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi0);
        __m256d ax1 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi1);
        __m256d ax2 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi2);
        __m256d ax3 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi3);

        __m256d idx = _mm256_set_pd(i + 4, i + 3, i + 2, i + 1);

        __m256d k0 = _mm256_add_pd(idx, _mm256_set1_pd(1.0));
        __m256d k1 = _mm256_add_pd(idx, _mm256_set1_pd(2.0));
        __m256d k2 = _mm256_add_pd(idx, _mm256_set1_pd(3.0));
        __m256d k3 = _mm256_add_pd(idx, _mm256_set1_pd(4.0));

        __m256d s0 = _mm256_mul_pd(k0, ax0);
        s0 = _mm256_mul_pd(s0, h0);
        __m256d s1 = _mm256_mul_pd(k1, ax1);
        s1 = _mm256_mul_pd(s1, h1);
        __m256d s2 = _mm256_mul_pd(k2, ax2);
        s2 = _mm256_mul_pd(s2, h2);
        __m256d s3 = _mm256_mul_pd(k3, ax3);
        s3 = _mm256_mul_pd(s3, h3);

        __m256d sum0 = _mm256_add_pd(s0, s1);
        __m256d sum1 = _mm256_add_pd(s2, s3);
        __m256d sum = _mm256_add_pd(sum0, sum1);

        _mm256_storeu_pd(&y[i], sum);
    }
}
```
>>>
Starting program. 2 functions registered.
The result of the 2th function is not correct.

Running: slow_performance
6082.31 cycles

Running: maxperformance
1218.62 cycles
<<<
WA
================================
```cpp
#include <immintrin.h>
#include <cmath>
#include <stdint.h>

void max_performance(double *__restrict x, double *__restrict y, double *__restrict h, int n, int m)
{
    const int unroll = 4;
    const __m256d h0 = _mm256_set1_pd(h[0]);
    const __m256d h1 = _mm256_set1_pd(h[1]);
    const __m256d h2 = _mm256_set1_pd(h[2]);
    const __m256d h3 = _mm256_set1_pd(h[3]);

    for (int i = 0; i < n; i += unroll)
    {
        __m256d xi0 = _mm256_loadu_pd(&x[i + 3]); // x[i+3], x[i+2], x[i+1], x[i]
        __m256d absxi0 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi0);

        __m256d xi1 = _mm256_loadu_pd(&x[i + 2]); // x[i+2], x[i+1], x[i], x[i-1]
        __m256d absxi1 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi1);

        __m256d xi2 = _mm256_loadu_pd(&x[i + 1]); // x[i+1], x[i], x[i-1], x[i-2]
        __m256d absxi2 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi2);

        __m256d xi3 = _mm256_loadu_pd(&x[i + 0]); // x[i], x[i-1], x[i-2], x[i-3]
        __m256d absxi3 = _mm256_andnot_pd(_mm256_set1_pd(-0.0), xi3);

        __m256d idx = _mm256_set_pd(i + 3, i + 2, i + 1, i + 0);
        __m256d one = _mm256_set1_pd(1.0);

        __m256d ik0 = _mm256_add_pd(idx, one);
        __m256d ik1 = _mm256_add_pd(idx, _mm256_set1_pd(2.0));
        __m256d ik2 = _mm256_add_pd(idx, _mm256_set1_pd(3.0));
        __m256d ik3 = _mm256_add_pd(idx, _mm256_set1_pd(4.0));

        __m256d sum = _mm256_mul_pd(ik0, _mm256_mul_pd(h0, absxi0));
        sum = _mm256_fmadd_pd(ik1, _mm256_mul_pd(h1, absxi1), sum);
        sum = _mm256_fmadd_pd(ik2, _mm256_mul_pd(h2, absxi2), sum);
        sum = _mm256_fmadd_pd(ik3, _mm256_mul_pd(h3, absxi3), sum);

        _mm256_storeu_pd(&y[i], sum);
    }
}
```
>>>
Starting program. 2 functions registered.

Running: slow_performance
6212.5 cycles

Running: maxperformance
1417.11 cycles
<<<
4.383922207873772
================================