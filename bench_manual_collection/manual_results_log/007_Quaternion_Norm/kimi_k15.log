Rewrite `slow_performance` into `max_performance`, keeping inputs, outputs, and behavior identical with allowable total squared precision error of 1e-3.  
Only apply performance optimizations (algebraic simplification, cache-friendly memory access, SIMD/AVX-2, loop unrolling, etc.).  

**Assume the code executes on a single core, DO NOT introduce multithreading or parallelism.**

**Target system**
- Intel(R) Core(TM) Ultra 7 265K CPU @ 3.90GHz
- Caches: 240 KB L1 D + 32 KB L1 I per core, 3.00 MB L2 per core, 30 MB shared L3  
- GCC 12 on Debian Bookworm; compile with `-O3 -march=native -mavx2 -std=c++11`

**Hints**
- Write SIMDe code with <immintrin.h> whenever possible.
- Do not use libc functions as their performance is not good.

Return **only** the full, ready-to-compile `max_performance` functionâ€”no other text, comments, or explanations.


```
#include <immintrin.h>
#include "common.h"

// x, y, z are __attribute__((aligned(32)))
void slow_performance(double *__restrict x, double *__restrict y)
{
    const double _c[4] = {2.0, 5.0, 0.25, 0.75};
    const double c0 = _c[0], c1 = _c[1], c2 = _c[2], c3 = _c[3];
    for (size_t i = 0; i < N; ++i)
    {
        double *xi = &(x[i * 4]);
        double a = c0 * xi[0] - c1 * xi[1] - c2 * xi[2] - c3 * xi[3];
        double b = c0 * xi[1] + c1 * xi[0] + c2 * xi[3] - c3 * xi[2];
        double c = c0 * xi[2] - c1 * xi[3] + c2 * xi[0] + c3 * xi[1];
        double d = c0 * xi[3] + c1 * xi[2] - c2 * xi[1] + c3 * xi[0];
        y[i] = a * a + b * b + c * c + d * d;
    }
}

void max_performance(double *__restrict x, double *__restrict y)
{
}
```


================================
#include <immintrin.h>
#include "common.h"

void max_performance(double *__restrict x, double *__restrict y)
{
    const double c0 = 2.0, c1 = 5.0, c2 = 0.25, c3 = 0.75;
    const __m256d coeff_x0 = _mm256_set_pd(0.75, 0.25, 5.0, 2.0);
    const __m256d coeff_x1 = _mm256_set_pd(-0.25, 0.75, 2.0, -5.0);
    const __m256d coeff_x2 = _mm256_set_pd(5.0, 2.0, -0.75, -0.25);
    const __m256d coeff_x3 = _mm256_set_pd(2.0, -5.0, 0.25, -0.75);

    for (size_t i = 0; i < N; ++i)
    {
        __m256d v_x = _mm256_load_pd(&x[i*4]);
        double x0 = _mm256_extract_pd(v_x, 0);
        double x1 = _mm256_extract_pd(v_x, 1);
        double x2 = _mm256_extract_pd(v_x, 2);
        double x3 = _mm256_extract_pd(v_x, 3);

        __m256d v_x0 = _mm256_set1_pd(x0);
        __m256d v_x1 = _mm256_set1_pd(x1);
        __m256d v_x2 = _mm256_set1_pd(x2);
        __m256d v_x3 = _mm256_set1_pd(x3);

        __m256d term0 = _mm256_mul_pd(v_x0, coeff_x0);
        __m256d term1 = _mm256_mul_pd(v_x1, coeff_x1);
        __m256d term2 = _mm256_mul_pd(v_x2, coeff_x2);
        __m256d term3 = _mm256_mul_pd(v_x3, coeff_x3);

        __m256d sum_terms = _mm256_add_pd(_mm256_add_pd(term0, term1), _mm256_add_pd(term2, term3));
        __m256d sum_squares = _mm256_dp_pd(sum_terms, sum_terms, 0xFF);
        y[i] = _mm256_extract_pd(sum_squares, 0);
    }
}
>>>
make: *** [Makefile:13: benchmark] Error 1
<<<
CE
================================
#include <immintrin.h>
#include "common.h"

void max_performance(double *__restrict x, double *__restrict y)
{
    const double _c[4] = {2.0, 5.0, 0.25, 0.75};
    const double c0 = _c[0], c1 = _c[1], c2 = _c[2], c3 = _c[3];
    const __m256d ca = _mm256_set_pd(-c3, -c2, -c1, c0);
    const __m256d cb = _mm256_set_pd(c2, -c3, c0, c1);
    const __m256d cc = _mm256_set_pd(-c1, c0, c3, c2);
    const __m256d cd = _mm256_set_pd(c0, c1, -c2, c3);
    
    for (size_t i = 0; i < N; ++i) {
        __m256d vx = _mm256_load_pd(&x[i * 4]);
        __m256d va = _mm256_mul_pd(vx, ca);
        __m256d vb = _mm256_mul_pd(vx, cb);
        __m256d vc = _mm256_mul_pd(vx, cc);
        __m256d vd = _mm256_mul_pd(vx, cd);
        
        __m256d va_sq = _mm256_mul_pd(va, va);
        __m256d vb_sq = _mm256_mul_pd(vb, vb);
        __m256d vc_sq = _mm256_mul_pd(vc, vc);
        __m256d vd_sq = _mm256_mul_pd(vd, vd);
        
        __m256d sum_sq = _mm256_add_pd(va_sq, vb_sq);
        sum_sq = _mm256_add_pd(sum_sq, vc_sq);
        sum_sq = _mm256_add_pd(sum_sq, vd_sq);
        
        sum_sq = _mm256_hadd_pd(sum_sq, sum_sq);
        sum_sq = _mm256_hadd_pd(sum_sq, sum_sq);
        
        y[i] = _mm256_extract_pd(sum_sq, 0);
    }
}
>>>
make: *** [Makefile:13: benchmark] Error 1
<<<
CE
================================
#include <immintrin.h>
#include "common.h"

void max_performance(double *__restrict x, double *__restrict y)
{
    const double c0 = 2.0, c1 = 5.0, c2 = 0.25, c3 = 0.75;
    const __m256d contrib_x0 = _mm256_set_pd(c3, c2, c1, c0);
    const __m256d contrib_x1 = _mm256_set_pd(-c2, -c3, c0, -c1);
    const __m256d contrib_x2 = _mm256_set_pd(c1, c0, -c3, -c2);
    const __m256d contrib_x3 = _mm256_set_pd(c0, c1, c2, -c3);

    for (size_t i = 0; i < N; ++i)
    {
        __m256d vec_x = _mm256_load_pd(&x[i*4]);
        __m256d x0 = _mm256_permute_pd(vec_x, _MM_PERMUTE(0,0,0,0));
        __m256d x1 = _mm256_permute_pd(vec_x, _MM_PERMUTE(1,1,1,1));
        __m256d x2 = _mm256_permute_pd(vec_x, _MM_PERMUTE(2,2,2,2));
        __m256d x3 = _mm256_permute_pd(vec_x, _MM_PERMUTE(3,3,3,3));
        
        __m256d t0 = _mm256_mul_pd(x0, contrib_x0);
        __m256d t1 = _mm256_mul_pd(x1, contrib_x1);
        __m256d t2 = _mm256_mul_pd(x2, contrib_x2);
        __m256d t3 = _mm256_mul_pd(x3, contrib_x3);
        
        __m256d abc = _mm256_add_pd(t0, _mm256_add_pd(t1, t2));
        __m256d abcd = _mm256_add_pd(abc, t3);
        
        __m256d ss = _mm256_mul_pd(abcd, abcd);
        ss = _mm256_hadd_pd(ss, ss);
        ss = _mm256_hadd_pd(ss, ss);
        y[i] = _mm256_extract_pd(ss, 0);
    }
}
>>>
make: *** [Makefile:13: benchmark] Error 1
<<<
CE
================================